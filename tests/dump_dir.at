# -*- Autotest -*-

AT_BANNER([dump_dir])

## --------- ##
## dd_sanity ##
## --------- ##

AT_TESTFUN([dd_sanity],
[[
#include "internal_libreport.h"
#include <errno.h>
#include <assert.h>

void validate_dump_dir_contents(struct dump_dir *dd)
{
    int items = 0;
    assert(dd_exist(dd, FILENAME_TIME));
    ++items;

    assert(dd_exist(dd, FILENAME_KERNEL));
    ++items;

    assert(dd_exist(dd, FILENAME_HOSTNAME));
    ++items;

    assert(dd_exist(dd, FILENAME_ARCHITECTURE));
    ++items;

    assert(dd_exist(dd, FILENAME_OS_INFO));
    ++items;

    assert(dd_exist(dd, FILENAME_OS_RELEASE));
    ++items;

    assert(dd_exist(dd, FILENAME_OS_RELEASE));
    ++items;

    assert(dd_exist(dd, FILENAME_TYPE));
    ++items;

    assert(dd_exist(dd, FILENAME_LAST_OCCURRENCE));
    ++items;

    assert(dd_exist(dd, "at_test_text"));
    assert(dd_get_item_size(dd, "at_test_text") == 3);
    ++items;

    assert(dd_exist(dd, "at_test_binary"));
    assert(dd_get_item_size(dd, "at_test_binary") == 4);
    ++items;

    assert(dd_exist(dd, "at_test_services"));
    ++items;

    dd_save_text(dd, "at_test_to_delete", "deleted");
    assert(dd_exist(dd, "at_test_to_delete"));
    dd_delete_item(dd, "at_test_to_delete");
    assert(!dd_exist(dd, "at_test_to_delete"));

    DIR *d1 = dd_init_next_file(dd);
    assert(d1 != NULL);

    int counter = 0;
    char *short_name, *full_name;
    while (dd_get_next_file(dd, &short_name, &full_name))
    {
        ++counter;


        printf("Iter = %s\n", short_name);

        assert(short_name != NULL);
        assert(full_name != NULL);
        assert(strcmp(short_name, strrchr(full_name, '/') + 1) == 0);
        assert(strncmp(dd->dd_dirname, full_name, strlen(dd->dd_dirname)) == 0);
        assert(full_name[strlen(dd->dd_dirname)] == '/');
    }

    printf("Items = %d, Counter = %d\n", items, counter);
    assert(items == counter);

    DIR *d2 = dd_init_next_file(dd);
    assert(d2 != NULL);

    while (dd_get_next_file(dd, &short_name, &full_name))
        --counter;

    assert(counter == 0);
}

int main(int argc, char **argv)
{
    g_verbose = 3;

    char template[] = "/tmp/XXXXXX/dump_dir";

    char *last_slash = strrchr(template, '/');
    *last_slash = '\0';

    if (mkdtemp(template) == NULL) {
        perror("mkdtemp()");
        return EXIT_FAILURE;
    }

    *last_slash = '/';

    printf("Dump dir path: %s\n", template);

    fprintf(stderr, "Create new dump directory\n");
    struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
    assert(dd != NULL || !"Cannot create new dump directory");

    dd_create_basic_files(dd, geteuid(), NULL);
    dd_save_text(dd, FILENAME_TYPE, "attest");

    dd_save_text(dd, "at_test_text", "foo");
    assert(dd_exist(dd, "at_test_text"));

    dd_save_binary(dd, "at_test_binary", "blah", 4);
    assert(dd_exist(dd, "at_test_binary"));

    dd_copy_file(dd, "at_test_services", "/etc/services");

    fprintf(stderr, "Test newly created dump directory\n");
    validate_dump_dir_contents(dd);
    dd_close(dd);


    fprintf(stderr, "Test opened dump directory\n");
    dd = dd_opendir(template, /*for writing*/0);
    assert(dd != NULL || !"Cannot open the dump directory");
    validate_dump_dir_contents(dd);
    dd_close(dd);


    fprintf(stderr, "Test renamed dump directory\n");
    dd = dd_opendir(template, /*for writing*/0);
    assert(dd != NULL || !"Cannot open the dump directory second time");

    *(last_slash+1) = 'X';
    assert(dd_rename(dd, template) == 0 || !"Cannot rename the dump directory");

    validate_dump_dir_contents(dd);
    dd_close(dd);


    fprintf(stderr, "Test opened renamed dump directory\n");
    assert(dd != NULL || !"Cannot open the renamed dump directory");
    dd = dd_opendir(template, /*for writing*/0);
    validate_dump_dir_contents(dd);

    assert(dd_delete(dd) == 0);

    *last_slash = '\0';
    assert(rmdir(template) == 0);
    return EXIT_SUCCESS;
}
]])

## --------------------- ##
## dd_create_open_delete ##
## --------------------- ##

AT_TESTFUN([dd_create_open_delete],
[[
#include "internal_libreport.h"
#include <errno.h>
#include <assert.h>

int main(int argc, char **argv)
{
    g_verbose = 3;

    char template[] = "/tmp/XXXXXX/dump_dir";

    char *last_slash = strrchr(template, '/');
    *last_slash = '\0';

    if (mkdtemp(template) == NULL) {
        perror("mkdtemp()");
        return EXIT_FAILURE;
    }

    *last_slash = '/';

    struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
    assert(strcmp(dd->dd_dirname, template) == 0);
    assert(dd->dd_fd >= 0);
    assert(dd->dd_md_fd >= 0);

    struct stat dd_st;
    assert(fstat(dd->dd_fd, &dd_st) == 0);

    struct stat md_st;
    assert(fstat(dd->dd_md_fd, &md_st) == 0);

    assert(dd_st.st_uid == md_st.st_uid);
    assert(dd_st.st_gid == md_st.st_gid);
    assert((dd_st.st_mode & 0666) == (md_st.st_mode & 0666));

    struct stat path_md_st;
    assert(fstatat(dd->dd_fd, ".libreport", &path_md_st, 0) == 0);
    assert(md_st.st_ino = path_md_st.st_ino);

    struct stat owner_md_st;
    assert(fstatat(dd->dd_md_fd, "owner", &owner_md_st, 0) == 0);
    assert((dd_st.st_mode & 0666) == (owner_md_st.st_mode & 0666));
    assert(geteuid() == dd_get_owner(dd));

    dd_create_basic_files(dd, (uid_t)-1, NULL);
    dd_save_text(dd, FILENAME_TYPE, "attest");

    dd_close(dd);
    dd = NULL;

    dd = dd_opendir(template, 0);
    assert(dd != NULL);
    assert(strcmp(dd->dd_dirname, template) == 0);
    assert(dd->dd_fd >= 0);
    assert(dd->dd_md_fd < 0);

    dd_delete(dd);

    assert(stat(template, &dd_st) != 0);

    *last_slash = '\0';
    assert(rmdir(template) == 0);
    return EXIT_SUCCESS;
}
]])

## -------------------------- ##
## dd_sanitize_mode_and_owner ##
## -------------------------- ##

AT_TESTFUN([dd_sanitize_mode_and_owner],
[[
#include "internal_libreport.h"
#include <errno.h>
#include <assert.h>

int main(int argc, char **argv)
{
    g_verbose = 3;

    char template[] = "/tmp/XXXXXX/dump_dir";

    char *last_slash = strrchr(template, '/');
    *last_slash = '\0';

    if (mkdtemp(template) == NULL) {
        perror("mkdtemp()");
        return EXIT_FAILURE;
    }

    *last_slash = '/';

    /* Prepare a directory for chmod test, use mode 0600 and chmod it to 0640 */
    struct dump_dir *dd = dd_create(template, (uid_t)-1, 0600);
    assert(dd != NULL);

    {
        struct stat path_md_st;
        assert((fstatat(dd->dd_fd, ".libreport", &path_md_st, 0) == 0) || !"Failed initialize meta-data");
        assert((path_md_st.st_mode & 0077) == 0);
    }

    dd_create_basic_files(dd, (uid_t)-1, NULL);
    dd_save_text(dd, FILENAME_TYPE, "attest");

    dd_close(dd);

    /* initialize meta-data */
    dd = dd_opendir(template, DD_OPEN_FD_ONLY);
    /* reopen for writing */
    dd = dd_fdopendir(dd, /*for writing*/0);
    assert(dd != NULL);

    assert(fchmod(dd->dd_fd, 0750) == 0);
    dd->mode = 0640;

    fprintf(stderr, "Going to sanitize\n");
    dd_sanitize_mode_and_owner(dd);
    fprintf(stderr, "Sanitized\n");

    {
        DIR *d = opendir(template);
        struct dirent *dent;
        while ((dent = readdir(d)) != NULL)
        {
            if (   strcmp(".", dent->d_name) == 0
                || strcmp("..", dent->d_name) == 0
                || strcmp(".lock", dent->d_name) == 0
                || strcmp(".libreport", dent->d_name) == 0
                )
                continue;

            struct stat sb;
            printf("Testing element: %s\n", dent->d_name);
            assert(fstatat(dd->dd_fd, dent->d_name, &sb, 0) == 0 || !"Cannot stat a regular element");
            assert((sb.st_mode & 0777) == 0640 || !"Failed to chmod a regular element");
        }
        closedir(d);
    }

    {
        struct stat path_md_st;
        assert(fstatat(dd->dd_fd, ".libreport", &path_md_st, 0) == 0 || !"Cannot stat meta-data directory");
        assert((path_md_st.st_mode & 0777) == 0750 || !"Failed chmod meta-data");
    }

    int md_dir_fd = openat(dd->dd_fd, ".libreport", O_DIRECTORY);
    assert(md_dir_fd >= 0 || !"Cannot open meta-data directory");
    DIR *d = fdopendir(md_dir_fd);
    struct dirent *dent;
    while ((dent = readdir(d)) != NULL)
    {
        if (strcmp(".", dent->d_name) == 0 || strcmp("..", dent->d_name) == 0)
            continue;

        struct stat sb;
        printf("Testing meta-data: %s\n", dent->d_name);
        assert(fstatat(md_dir_fd, dent->d_name, &sb, 0) == 0 || !"Cannot stat meta-data file");
        assert((sb.st_mode & 0777) == 0640 || !"Failed to chmod a meta-data file");
    }

    closedir(d);
    dd_delete(dd);

    *last_slash = '\0';
    assert(rmdir(template) == 0);
    return EXIT_SUCCESS;
}
]])

## -------- ##
## dd_owner ##
## -------- ##

AT_TESTFUN([dd_owner],
[[
#include "internal_libreport.h"
#include <errno.h>
#include <assert.h>

int main(int argc, char **argv)
{
    g_verbose = 3;

    char template[] = "/tmp/XXXXXX/dump_dir";

    char *last_slash = strrchr(template, '/');
    *last_slash = '\0';

    if (mkdtemp(template) == NULL) {
        perror("mkdtemp()");
        return EXIT_FAILURE;
    }

    *last_slash = '/';

    printf("Dump dir path: %s\n", template);

    {
        fprintf(stderr, "TEST === default owner\n");
        struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
        assert(dd != NULL);

        assert(geteuid() == dd_get_owner(dd));

        assert(dd_delete(dd) == 0);
    }

    {
        fprintf(stderr, "TEST === create basic files w/o UID\n");
        struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
        assert(dd != NULL);

        dd_create_basic_files(dd, (uid_t)-1, NULL);
        assert(geteuid() == dd_get_owner(dd));

        assert(dd_delete(dd) == 0);
    }

    {
        fprintf(stderr, "TEST === create basic files with UID\n");
        struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
        assert(dd != NULL);

        dd_create_basic_files(dd, (geteuid() + 1), NULL);
        assert((geteuid() + 1) == dd_get_owner(dd));

        assert(dd_delete(dd) == 0);
    }

    {
        fprintf(stderr, "TEST === set no owner\n");
        struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
        assert(dd != NULL);

        dd_set_no_owner(dd);

        struct passwd *nobody_pw= getpwnam("nobody");
        assert(nobody_pw != NULL);
        assert(nobody_pw->pw_uid == dd_get_owner(dd));

        assert(dd_delete(dd) == 0);
    }

    {
        fprintf(stderr, "TEST === set artibrary owner\n");
        struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
        assert(dd != NULL);

        dd_set_owner(dd, (geteuid() + 2));
        assert((geteuid() + 2) == dd_get_owner(dd));

        assert(dd_delete(dd) == 0);
    }

    {
        fprintf(stderr, "TEST === chown no owner\n");
        struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
        assert(dd != NULL);

        dd_set_no_owner(dd);
        assert(geteuid() != dd_get_owner(dd));

        dd_chown(dd, geteuid());
        assert(geteuid() == dd_get_owner(dd));

        assert(dd_delete(dd) == 0);
    }
    *last_slash = '\0';
    assert(rmdir(template) == 0);

    return EXIT_SUCCESS;
}
]])

## -------------- ##
## recursive_lock ##
## -------------- ##

AT_TESTFUN([recursive_lock],
[[
#include "internal_libreport.h"
#include <errno.h>
#include <assert.h>

int main(int argc, char **argv)
{
    g_verbose = 3;

    char *path = tmpnam(NULL);
    struct dump_dir *dd = dd_create(path, -1L, DEFAULT_DUMP_DIR_MODE);

    char *lock_path = concat_path_file(path, ".lock");
    struct stat buf;

    assert(dd);

    assert(lstat(lock_path, &buf) == 0 && S_ISLNK(buf.st_mode));

    dd_create_basic_files(dd, -1L, "/");
    dd_save_text(dd, "type", "custom");

    struct dump_dir *dd2 = dd_opendir(path, DD_OPEN_READONLY);
    assert(dd2->owns_lock == 0);

    struct dump_dir *dd3 = dd_opendir(path, 0);
    assert(dd3->owns_lock == 0);

    dd_close(dd2);
    assert(lstat(lock_path, &buf) == 0 && S_ISLNK(buf.st_mode));

    dd_close(dd3);
    assert(lstat(lock_path, &buf) == 0 && S_ISLNK(buf.st_mode));

    dd_close(dd);

    assert(stat(lock_path, &buf) != 0 && errno == ENOENT);
    free(lock_path);

    return 0;
}
]])

## ----------------------- ##
## str_is_correct_filename ##
## ----------------------- ##

AT_TESTFUN([str_is_correct_filename],
[[
#include "internal_libreport.h"
#include <assert.h>
#
int main(void)
{
    g_verbose = 3;

    assert(str_is_correct_filename("") == false);
    assert(str_is_correct_filename("/") == false);
    assert(str_is_correct_filename("//") == false);
    assert(str_is_correct_filename(".") == false);
    assert(str_is_correct_filename(".") == false);
    assert(str_is_correct_filename("..") == false);
    assert(str_is_correct_filename("..") == false);
    assert(str_is_correct_filename("/.") == false);
    assert(str_is_correct_filename("//.") == false);
    assert(str_is_correct_filename("./") == false);
    assert(str_is_correct_filename(".//") == false);
    assert(str_is_correct_filename("/./") == false);
    assert(str_is_correct_filename("/..") == false);
    assert(str_is_correct_filename("//..") == false);
    assert(str_is_correct_filename("../") == false);
    assert(str_is_correct_filename("..//") == false);
    assert(str_is_correct_filename("/../") == false);
    assert(str_is_correct_filename("/.././") == false);

    assert(str_is_correct_filename("looks-good-but-evil/") == false);
    assert(str_is_correct_filename("looks-good-but-evil/../../") == false);

    assert(str_is_correct_filename(".meta-data") == true);
    assert(str_is_correct_filename("..meta-meta-data") == true);
    assert(str_is_correct_filename("meta-..-data") == true);

    assert(str_is_correct_filename("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890+-") == true);
    assert(str_is_correct_filename("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890+-=") == false);

    return 0;
}
]])

## --------------- ##
## create_dump_dir ##
## --------------- ##

AT_TESTFUN([create_dump_dir],
[[
#include "internal_libreport.h"
#include <assert.h>
#
int main(void)
{
    g_verbose = 3;

    char template[] = "/tmp/XXXXXX";

    if (mkdtemp(template) == NULL) {
        perror("mkdtemp()");
        return EXIT_FAILURE;
    }

    printf("Base dump dir path: %s\n", template);

    dd_g_fs_group_gid = getegid();

    problem_data_t *pd = problem_data_new();

    problem_data_add_text_editable(pd, FILENAME_TYPE, "attest");

    {
        fprintf(stderr, "=== NO UID - geteuid() ===\n");
        struct dump_dir *no_uid_dd_geteuid = create_dump_dir_from_problem_data_ext(pd, template, geteuid());
        assert(no_uid_dd_geteuid != NULL);
        assert(dd_get_owner(no_uid_dd_geteuid) == geteuid());
        assert(dd_delete(no_uid_dd_geteuid) == 0);
        fprintf(stderr, "=== NO UID - geteuid() ===\n");
    }

    {
        fprintf(stderr, "=== NO UID - NO UID ===\n");
        struct dump_dir *no_uid_dd_nouid = create_dump_dir_from_problem_data_ext(pd, template, (uid_t)-1L);
        assert(no_uid_dd_nouid != NULL);
        assert(dd_get_owner(no_uid_dd_nouid) == geteuid());
        assert(dd_delete(no_uid_dd_nouid) == 0);
        fprintf(stderr, "=== NO UID - NO UID ===\n");
    }

    char buf[sizeof(long)*3 + 2];
    snprintf(buf, sizeof(buf), "%ld", (long)(geteuid() + 1));
    problem_data_add_text_editable(pd, FILENAME_UID, buf);

    {
        fprintf(stderr, "=== UID - geteuid() ===\n");
        struct dump_dir *uid_dd_geteuid = create_dump_dir_from_problem_data_ext(pd, template, geteuid());
        assert(uid_dd_geteuid != NULL);
        assert(dd_get_owner(uid_dd_geteuid) == (geteuid() + 1));
        assert(dd_delete(uid_dd_geteuid) == 0);
        fprintf(stderr, "=== UID - geteuid() ===\n");
    }

    {
        fprintf(stderr, "=== UID - NO UID ===\n");
        struct dump_dir *uid_dd_nouid = create_dump_dir_from_problem_data_ext(pd, template, (uid_t)-1L);
        assert(uid_dd_nouid != NULL);
        assert(dd_get_owner(uid_dd_nouid) == (geteuid() + 1));
        assert(dd_delete(uid_dd_nouid) == 0);
        fprintf(stderr, "=== UID - NO UID ===\n");
    }

    assert(rmdir(template) == 0);
    return EXIT_SUCCESS;
}
]])
